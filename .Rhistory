return(c(initial.growth, #initial.carry.cap,
initial.move.const, initial.log.sigma))
}
quit = function() {
return(invisible())
}
if (is.null(theta)) theta = initial()
if (length(theta) == 0) theta = initial()
val = do.call(match.arg(cmd), args = list())
return(val)
}
define.loggrow.model <- function(linpoint, smesh, tmesh, step.size,
prior.mean, prior.precision,
priors = NULL, grad = NULL,
initial.growth = NULL, initial.carry.cap = NULL,
initial.move.const = NULL, initial.log.sigma = NULL){
if(is.null(grad)){
grad <- gradient_of_linpoint(linpoint, smesh, tmesh)
}
the_model <- inla.rgeneric.define(log.growth.rgeneric,
linpoint = linpoint,
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean, priors = priors,
prior.precision = prior.precision,
grad = grad,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma)
class(the_model) <- c("log_growth_model", class(the_model))
the_model[["smesh"]] <- smesh
the_model[["tmesh"]] <- tmesh
return(the_model)
}
#'@name bru_get_mapper.log_growth_model
#' @title Mapper function for internal use
#' @export
bru_get_mapper.log_growth_model <- function(model, ...) {
stopifnot(requireNamespace("inlabru"))
inlabru::bru_mapper_multi(list(
space = inlabru::bru_mapper(model[["smesh"]]),
time = inlabru::bru_mapper(model[["tmesh"]], indexed = TRUE)
))
}
iterate.fit.lgcp <- function(data, smesh, tmesh, samplers,prior.mean,
prior.precision, max.iter = 100,gamma = 0.5,stop.crit = 0.05,
priors = NULL, initial.linpoint = NULL, initial.growth=1,
initial.carry.cap=100, initial.move.const = 1, initial.log.sigma = log(1.5),
verbose = F){
#browser()
step.size = (tmesh$interval[2]-tmesh$interval[1])/(tmesh$n-1) #calculate step size. -1 in denom due to fence post problem
if(is.null(initial.linpoint)){
initial.linpoint <- log(logit.nest(exp(prior.mean), exp(initial.growth), initial.carry.cap, tmesh$n)$x)
}
if(!is.matrix(initial.linpoint)) initial.linpoint <- as.matrix(initial.linpoint, ncol = 1)
#Set up initial model
fit.list <- list()
log_growth_model <- define.loggrow.model(linpoint = initial.linpoint,
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma)
fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose))
fit.list[[1]]<-fit
print("First fitting finished")
n.nodes <- fit$misc$configs$nconfig
nodes <- data.frame(log.prob=rep(NA,n.nodes))
#mat_list <- list()
mean_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- fit$misc$configs$config[[i]]$log.posterior
#mat_list[[i]] <- fit$misc$configs$config[[i]]$Q[1:(smesh$n*tmesh$n), 1:(smesh$n*tmesh$n)]
mean_list[[i]] <- fit$misc$configs$config[[i]]$improved.mean[1:(smesh$n*tmesh$n)]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
#Old rule- in theory faster but gives some extreme changes
#P <- Reduce("+", Map(function(m, w) m * w, mat_list, nodes$weight.prob))
#weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
#b <- Reduce("+", Map(function(m,w) m%*%w, mat_list,weighted.means))
#new.linpoint <- (1-gamma)*initial.linpoint +gamma*solve(P,b)
#New update rule
weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
new.mean <- Reduce("+", weighted.means)
new.linpoint <- (1-gamma)*initial.linpoint +gamma*new.mean
print("Calcualted new linpoint")
lp.mat <- cbind(initial.linpoint,new.linpoint)
n <- 2
#print(fit$summary.hyperpar$mean)
while(n < max.iter & mean(abs(lp.mat[,n]-lp.mat[,n-1]))>stop.crit){
log_growth_model <- define.loggrow.model(linpoint = as.vector(new.linpoint),
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = fit$summary.hyperpar$mean[1],
initial.carry.cap = initial.carry.cap,
initial.move.const = fit$summary.hyperpar$mean[2],
initial.log.sigma = fit$summary.hyperpar$mean[3])
print("Defined new model")
fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose))
print(paste("Fitted new model", n))
fit.list[[n]]<-fit
n.nodes <- fit$misc$configs$nconfig
if(!is.numeric(n.nodes)){
print("Failed to fit, trying again")
fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose))
n.nodes <- fit$misc$configs$nconfig
if(!is.numeric(fit$misc$configs$nconfig)){
print("Failed again, returning model output")
return(list(new.linpoint = new.linpoint,fit = fit, past.linpoints = lp.mat, fit.list = fit.list))
}
fit.list[[n]]<-fit
}
nodes <- data.frame(log.prob=rep(NA,n.nodes))
#mat_list <- list()
mean_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- fit$misc$configs$config[[i]]$log.posterior
#mat_list[[i]] <- fit$misc$configs$config[[i]]$Q[1:(smesh$n*tmesh$n),1:(smesh$n*tmesh$n)]
mean_list[[i]] <- fit$misc$configs$config[[i]]$improved.mean[1:(smesh$n*tmesh$n)]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
#P <- Reduce("+", Map(function(m, w) m * w, mat_list, nodes$weight.prob))
#weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
#b <- Reduce("+", Map(function(m,w) m%*%w, mat_list,weighted.means))
#new.linpoint <- (1-gamma)*lp.mat[,n] +gamma*solve(P,b)
#New update rule
weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
new.mean <- Reduce("+", weighted.means)
new.linpoint <- (1-gamma)*lp.mat[,n-1] +gamma*new.mean
lp.mat <- cbind(lp.mat,new.linpoint)
print("Updated linpoint")
n <- n+1
}
log_growth_model <- define.loggrow.model(linpoint = as.vector(new.linpoint),
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = fit$summary.hyperpar$mean[1],
initial.carry.cap = initial.carry.cap,
initial.move.const = fit$summary.hyperpar$mean[2],
initial.log.sigma = fit$summary.hyperpar$mean[3])
print("Defined final model")
final.fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose))
return(list(fit = final.fit, n = n, linpoints = lp.mat, fit_list = fit.list))
}
# Simulate data -----------------------------------------------------------
simulate_loggrowth<- function(growth, k, movement, sigma,
initial, timesteps, npoints = NULL, obs.sd=NULL,
sample.type = "LGCP", ncores = 1,
boundaries = c(0,1)){
#browser()
#Set up boundary and mesh
corners <- c(boundaries[1] - movement, boundaries[2]+movement)
bnd_extended <- inlabru::spoly(data.frame(easting = c(corners[1], corners[2],corners[2],corners[1]),
northing = c(corners[1], corners[1],corners[2],corners[2])))
mesh_extended <- fmesher::fm_mesh_2d_inla(boundary = bnd_extended, max.edge = c((corners[2]-corners[1])/50, (corners[2]-corners[1])/5))
mesh_time <- fmesher::fm_mesh_1d(loc = 1:timesteps)
#animal initial field
matern_extended <-
inla.spde2.pcmatern(mesh_extended,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern_extended,
theta = log(c(movement, sigma)))
initial_field <- inla.qsample(1, initial_Q, mu = rep(initial, nrow(initial_Q)))[, 1]
animal_field <- data.frame(time = 1, field = initial_field)
for(i in 2:timesteps){
mu <- logit.growth(animal_field$field[animal_field$time == i-1],
growth,k)
animal_field<-rbind(animal_field,
data.frame(time = i,
field = inla.qsample(1, initial_Q, mu = mu)[, 1]))
}
#Expand for plots
expand_for_plot <- function(i){
animal_tempsf <- expand.grid(
easting = seq(corners[1],corners[2], by = 0.01),
northing = seq(corners[1],corners[2], by = 0.01))
animal_tempsf <- dplyr::mutate(sf::st_as_sf(animal_tempsf, coords = c("easting", "northing")),
time = i)
animal_tempsf$field <- fmesher::fm_evaluate(
mesh_extended,
loc = animal_tempsf,
field = animal_field$field[animal_field$time == i])
return(animal_tempsf)
}
expanded <- parallel::mclapply(1:timesteps, expand_for_plot,  mc.cores = ncores)
animal <- do.call(rbind, expanded)
bnd_inner <- sf::st_as_sf(inlabru::spoly(data.frame(easting = c(boundaries[1],boundaries[2],boundaries[2],boundaries[1]),
northing = c(boundaries[1], boundaries[1], boundaries[2], boundaries[2]))))
if(sample.type == "Normal"){
points.to.sample <- sample(unique(sf::st_filter(animal,bnd_inner)$geometry),
npoints)
animal_obs <- filter(animal, geometry %in% points.to.sample) %>%
dplyr::mutate(obs = rnorm(npoints*(timesteps), field, obs.sd))
}
if(sample.type == "LGCP"){
animal_field$field[animal_field$field <0] <- 0.00001
simulate_obs <- function(i){
samp_animal <- sample.lgcp(mesh_extended,
loglambda = log(animal_field$field[animal_field$time == i]),
samplers = bnd_inner)
samp_animal <- sf::st_as_sf(samp_animal, coords = c("x","y"))
samp_animal_df <- dplyr::mutate(samp_animal, time = i)
return(samp_animal_df)
}
observations <- parallel::mclapply(1:timesteps, simulate_obs,  mc.cores =  ncores)
animal_obs <- do.call(rbind, observations)
#remove edge effects
#animal_obs <- st_as_sf(animal_obs, coords = c("x","y"))
}
return(list(animal = animal,animal_field = animal_field,
animal_obs = animal_obs))
}
# Actual fitting ----------------------------------------------------------
out.lgcp <- simulate_loggrowth(growth = 0.8, k = 50, movement = 0.75, sigma = 1,
initial = 25,timesteps = 5,sample.type = "LGCP", boundaries = c(0,5))
#fit initial year
bnd <- spoly(data.frame(easting = c(0,5,5,0), northing = c(0,0,5,5)))
mesh_obs <- fm_mesh_2d(boundary = bnd,
max.edge = c(0.25,1), offset = c(-0.1,1.5))
bnd <- st_as_sf(bnd)
mesh_time <- fm_mesh_1d(loc = 1:5)
matern <- inla.spde2.pcmatern(mesh_obs,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
cmp <- geometry ~ smooth(geometry, model = matern) +
initial(1,model = "linear", mean.linear = log(length(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,])))-1
fit0 <- bru(cmp, out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,],domain = list(geometry = mesh_obs),
family = "cp",samplers = bnd)
#Find fitted values on mesh points
library(stringr)
index <- min(which(str_sub(rownames(fit0$summary.fitted.values),8,8)!= "A"))
n.nodes <- fit0$misc$configs$nconfig
nodes <- data.frame(log.prob=rep(NA,n.nodes))
mat_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- fit0$misc$configs$config[[i]]$log.posterior
mat_list[[i]] <- fit0$misc$configs$config[[i]]$Q[1:mesh_obs$n,1:mesh_obs$n]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
Q <- Reduce("+", Map(function(m,w) w*m, mat_list,nodes$weight.prob))
initial.precision <- Diagonal(mesh_obs$n,
1/((fit0$summary.fixed$sd**2)+(fit0$summary.fitted.values$sd[index-1 +1:mesh_obs$n]**2)))+Q
library(plot.matrix)
plot(initial.precision)
plot(as.matrix(initial.precision))
dim(initial.precision)
summary(initial.precision)
gc()
gc()
install.packages("palmerpenguins")
#' Cgeneric unit test
remotes::install_github("ljb34/INLAlogisticgrowth")
library(INLAloggrowth)
library(sf)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 200, movement = 1, sigma = 2,
initial = 100,timesteps = 4,sample.type = "LGCP")
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
library(tidyverse)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
#' Cgeneric unit test
remotes::install_github("ljb34/INLAlogisticgrowth")
library(INLAloggrowth)
library(sf)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
library(tidyverse)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
#' Cgeneric unit test
remotes::install_github("ljb34/INLAlogisticgrowth")
library(INLAloggrowth)
library(sf)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
options(repos = c(CRAN = "https://cloud.r-project.org"))
library(INLA)
remotes::install_github("ljb34/INLAlogisticgrowth")
fit0 <- bru(cmp, out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,],domain = list(geometry = mesh_obs),
family = "cp",samplers = bnd)
library(inlabru)
library(INLAloggrowth)
library(sf)
library(dplyr)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T,
max.edge = 0.05)
?q
sessionInfo()
#'sigma = 10,initial = 75,timesteps = 3)
#'if(require("ggplot2")){
#'ggplot()+
#'gg(test.data$animal_obs)+facet_wrap(~time)+ggtitle("Observed animals")
#'ggplot()+
#'gg(test.data$animal, aes(fill = field), geom = "tile")+facet_wrap(~time)+
#'ggtitle("Underlying field")
#'}
#'
#'@export
simulate.loggrowth <- function(growth, carry.cap, movement, sigma,
initial.pop,initial.range, initial.sigma,
timesteps, npoints = NULL, obs.sd=NULL,
obs.prob = NULL,
sample.type = "LGCP", ncores = 1,
boundaries = c(0,1), debug = F,
max.edge = 0.05){
browser()
#functions needed
a.func <- function(growth,carry.cap, linpoint){
#print("Calcualting a")
return(growth*exp(linpoint)/carry.cap)
}
#growth, carry.cap, move.const = theta params to be est
#step.size = difference in time between lin points, known
#linpoint = list of linearisation point vectors
#smesh = space mesh built with fmesher, tmesh = time mesh
L.matrix <- function(growth,carry.cap,move.const,step.size, linpoint, smesh, tmesh){
#print("Calcualting Lmat")
ns <- smesh$n
nt <- tmesh$n
a<- a.func(growth,carry.cap, linpoint)
a[1:ns] <- 1
a.mat <- Matrix::Diagonal(ns*nt,a)
subdiag <- Matrix::bandSparse(nt*ns, k = -ns, diagonals = list(rep(-1/step.size, (nt - 1)*ns)))
fem.matrices <- fmesher::fm_fem(smesh)
CinvG <- Matrix::solve(fem.matrices$c1, fem.matrices$g1)
main.diag <- Matrix::kronecker(Matrix::Diagonal(nt, c(0,rep(1, nt-1))),
Matrix::Diagonal(ns, 1/(step.size))+ move.const*CinvG)
#print(diag(main.diag + subdiag + a.mat))
return(Matrix::drop0(main.diag + subdiag + a.mat, tol = 1e-100))
}
r.vector <- function(growth,carry.cap,move.const,linpoint,grad){
mag.grad.sq <- rowSums(grad*grad) #magnitude squared
return(growth*exp(linpoint)*(linpoint-1)/carry.cap+ growth - move.const*mag.grad.sq )
}
interpret.theta = function() {
return(list(growth = theta[1L],
carry.cap = exp(theta[2L]),
move.const = theta[3L],
sigma = exp(theta[4L])))
}
Q = function(){
#browser()
#print("Calcualting Q")
par = interpret.theta()
#print(par)
Lmat = L.matrix(par$growth, par$carry.cap, par$move.const,step.size, linpoint, smesh, tmesh)
noiseonly = Matrix::Diagonal(smesh$n*(tmesh$n-1), 1/(par$sigma*step.size)**2)
noise.precision = Matrix::bdiag(list(prior.precision, noiseonly))
output = Matrix::crossprod(Lmat, noise.precision %*% Lmat)
#print(output[smesh$n:(smesh$n +10),smesh$n:(smesh$n +10)])
return(Matrix::drop0(output, 1e-100))
}
mu = function(){
#browser()
#print("Calcualting mu")
#if(class(theta)!="numeric"){
#  theta <- initial()
#}
par = interpret.theta()
#print(par)
Lmat = L.matrix(par$growth, par$carry.cap, par$move.const, step.size, linpoint, smesh, tmesh)
r = c(prior.mean, r.vector(par$growth, par$carry.cap, par$move.const, linpoint, grad)[-(1:smesh$n)])
Lmat_det <- Matrix::det(Lmat)
if(!is.nan(Lmat_det)) {
if(abs(Lmat_det) <= .Machine$double.eps){ #if close to singular use
#print(det(crossprod(Lmat,Lmat)))
mu = Matrix::solve(crossprod(Lmat,Lmat),crossprod(Lmat,r)) #more stable form of solve(lmat,r)
mu= as.vector(mu)
#print("Trick version")
}else{
mu = Matrix::solve(Lmat,r)
#print("Default Solve")
}}else{
print("There's some NaNs going on?")
mu = NA
}
#print(mean(mu))
return(mu)
}
#set up for simulation
corners <- c(boundaries[1] - 2*initial.range, boundaries[2]+2*initial.range)
bnd_extended <- inlabru::spoly(data.frame(easting = c(corners[1], corners[2],corners[2],corners[1]),
northing = c(corners[1], corners[1],corners[2],corners[2])))
smesh <- fmesher::fm_mesh_2d_inla(boundary = bnd_extended, max.edge = max.edge)
tmesh <- fmesher::fm_mesh_1d(loc = 0:timesteps)
step.size <- 1
if(debug) print("set up finished, generating first year")
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(initial.range, initial.sigma)))
prior.mean <- log(initial.pop) + inla.qsample(1, initial_Q)[,1]
if(debug){
#summary(exp(prior.mean))
print("Defining model")
}
#components needed for model
initial.growth <- growth
initial.carry.cap <- log(carry.cap)
initial.move.const <- movement
initial.log.sigma <- log(sigma)
theta <- c(initial.growth, initial.carry.cap, initial.move.const, initial.log.sigma)
linpoint <- log(logit.nest(exp(prior.mean), growth, carry.cap, tmesh$n)$x)
#plot(exp(linpoint))
grad <- gradient_of_linpoint(linpoint, smesh, tmesh)#
prior.precision <- initial_Q
if(debug) print("Calculating precision")
Q_mat <-Q()
if(debug) print("Calculating mean")
mu_mat <- mu()
#if(debug) plot(exp(mu_mat))
#generate field
if(debug) print("generating field")
field <- data.frame(field = inla.qsample(1, Q_mat, mu = mu_mat)[, 1])
field$time <- rep(0:timesteps, each = smesh$n)
expand_for_plot <- function(i){
animal_tempsf <- expand.grid(
easting = seq(corners[1],corners[2], by = 0.01),
northing = seq(corners[1],corners[2], by = 0.01))
animal_tempsf <- dplyr::mutate(sf::st_as_sf(animal_tempsf, coords = c("easting", "northing")),
time = i)
animal_tempsf$field <- fmesher::fm_evaluate(
smesh,
loc = animal_tempsf,
field = field$field[field$time == i])
return(animal_tempsf)
}
expanded <- parallel::mclapply(0:timesteps, expand_for_plot,  mc.cores = ncores)
animal <- do.call(rbind, expanded)
bnd_inner <- sf::st_as_sf(inlabru::spoly(data.frame(easting = c(boundaries[1],boundaries[2],boundaries[2],boundaries[1]),
northing = c(boundaries[1], boundaries[1], boundaries[2], boundaries[2]))))
if(debug) print("Sampling")
if(sample.type == "Normal"){
points.to.sample <- sample(unique(sf::st_filter(animal,bnd_inner)$geometry),
npoints)
animal_obs <- filter(animal, geometry %in% points.to.sample) %>%
dplyr::mutate(obs = rnorm(npoints*(tmesh$n), field, obs.sd))
}
if(sample.type == "LGCP"){
simulate_obs <- function(i){
samp_animal <- sample.lgcp(smesh,
loglambda = field$field[field$time == i],
samplers = bnd_inner)
samp_animal <- sf::st_as_sf(samp_animal, coords = c("x","y"))
samp_animal_df <- dplyr::mutate(samp_animal, time = i)
return(samp_animal_df)
}
observations <- parallel::mclapply(0:timesteps, simulate_obs,  mc.cores =  ncores)
animal_obs <- do.call(rbind, observations)
#remove edge effects
#animal_obs <- st_as_sf(animal_obs, coords = c("x","y"))
}
if(sample.type == "Bernoulli"){
points.to.sample <- sample(unique(sf::st_filter(animal,bnd_inner)$geometry),
npoints)
animal_obs <- filter(animal, geometry %in% points.to.sample) %>%
dplyr::mutate(obs = rbinom(npoints*(tmesh$n), 1, plogis(obs.prob*exp(field))))
}
return(list(animal = animal[animal$time !=0,],field = field[field$time != 0,],
animal_obs = animal_obs[animal_obs$time != 0,]))
}
out.lgcp <- simulate.loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T,
max.edge = 0.1)
library(INLAloggrowth)
setwd("~/GitHub/INLAlogrowth-package/R")
devtools::load_all()
setwd("~/GitHub/INLAlogrowth-package")
roxygen2::roxygenise()
