out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 200, movement = 1, sigma = 2,
initial = 100,timesteps = 4,sample.type = "LGCP")
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
library(tidyverse)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
#' Cgeneric unit test
remotes::install_github("ljb34/INLAlogisticgrowth")
library(INLAloggrowth)
library(sf)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
library(tidyverse)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
#' Cgeneric unit test
remotes::install_github("ljb34/INLAlogisticgrowth")
library(INLAloggrowth)
library(sf)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 200, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "LGCP", boundaries = c(0,1), debug = T)
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
setwd("~/INLAloggrowth results/17.11/21.11")
#priors = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
#growth = c(log(0.8),0.15),move = c(0.25,0.1),sigma = c(log(0.1),0.25))
#true K = 1000, growth =  0.8, move = 0.25, sigma = 0.1
#initial range 0.2, initial sigma = 0.01, initial pop 750
cgenfit <- readRDS("cgen_newupdate_initprec.RData")
for(i in 1:ncol(cgenfit$linpoints)){
plot(exp(cgenfit$linpoints[,i]), main = paste("Iteration ",i))
if(i > 1){
print(paste(i, ": ",mean(abs(cgenfit$linpoints[,i] - cgenfit$linpoints[,i-1]))))
#print(exp(cgenfit$fit_list[[i]]$summary.hyperpar[c(1,2,4),]))
}
}
#priors = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
#growth = c(log(0.8),0.15),move = c(0.25,0.1),sigma = c(log(0.1),0.25))
#true K = 1000, growth =  0.8, move = 0.25, sigma = 0.1
#initial range 0.2, initial sigma = 0.01, initial pop 750
cgenfit <- readRDS("cgen_newupdate_widefine_manyiter.RData")
summary(cgenfit$fit)
#priors = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
#growth = c(log(0.8),0.15),move = c(0.25,0.1),sigma = c(log(0.1),0.25))
#true K = 1000, growth =  0.8, move = 0.25, sigma = 0.1
#initial range 0.2, initial sigma = 0.01, initial pop 750
cgenfit <- readRDS("cgen_newupdate_widefine_manyiter.RData")
summary(cgenfit$fit)
exp(cgenfit$fit$summary.hyperpar[c(1,2,4),])
for(i in 1:ncol(cgenfit$linpoints)){
plot(exp(cgenfit$linpoints[,i]), main = paste("Iteration ",i))
if(i > 1){
print(paste(i, ": ",mean(abs(cgenfit$linpoints[,i] - cgenfit$linpoints[,i-1]))))
#print(exp(cgenfit$fit_list[[i]]$summary.hyperpar[c(1,2,4),]))
}
}
for(i in 1:ncol(cgenfit$linpoints)){
#plot(exp(cgenfit$linpoints[,i]), main = paste("Iteration ",i))
if(i > 1){
print(paste(i, ": ",mean(abs(cgenfit$linpoints[,i] - cgenfit$linpoints[,i-1]))))
print(exp(cgenfit$fit_list[[i]]$summary.hyperpar[c(1,2,4),]))
}
}
print(exp(cgenfit$fit_list$internal.summary.hyperpar))
dat <- cgenfit$data$animal
bnd <- st_as_sf(spoly(data.frame(easting = c(0,1,1,0), northing = c(0,0,1,1))))
truth <- st_filter(dat, bnd)
library(ggplot2)
library(patchwork)
library(inlabru)
library(sf)
library(patchwork)
colsc <- function(...) {
scale_fill_gradientn(
colours = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
limits = range(..., na.rm = TRUE)
)
}
bnd <- st_as_sf(spoly(data.frame(easting = c(0,1,1,0), northing = c(0,0,1,1))))
truth <- st_filter(dat, bnd)
ggplot()+
gg(truth, aes(fill = exp(field)), geom = "tile")+
#gg(dat$animal_obs, colour = "white")+
facet_wrap(~time)+colsc(exp(truth$field))
preds <- readRDS("cgen_newupdate_preds_widefine_manyiter.RData")
ggplot()+
gg(truth, aes(fill = exp(field)), geom = "tile")+
facet_wrap(~time)+colsc(exp(truth$field),preds$lambda$median)+
ggtitle("Truth")+
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(exp(truth$field),preds$lambda$median)+
ggtitle("Predicted")
#ggsave("newupdate.png")
for(i in 1:4){
print(ggplot()+
gg(preds$lambda[preds$lambda$time == i,], aes(fill = median), geom = "tile")+
colsc(preds$lambda$median[preds$lambda$time == i])+
ggtitle(paste("Predicted", i))+
ggplot()+
gg(truth[truth$time == i,], aes(fill = exp(field)), geom = "tile")+
ggtitle(paste("True", i))+
colsc(exp(truth$field[truth$time == i])))
#ggsave(paste("Newupdate",i,".png",sep = "_"))
}
111*10/60
preds <- readRDS("cgen_newupdate_preds_widefine_manyiter.RData")
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(exp(truth$field),preds$lambda$median)+
ggtitle("Predicted")
print(#ggplot()+
#  gg(preds$lambda[preds$lambda$time == i,], aes(fill = median), geom = "tile")+
#  colsc(preds$lambda$median[preds$lambda$time == i])+
#  ggtitle(paste("Predicted", i))+
ggplot()+
gg(truth[truth$time == i,], aes(fill = exp(field)), geom = "tile")+
ggtitle(paste("True", i))+
colsc(exp(truth$field[truth$time == i])))
print(ggplot()+
gg(preds$lambda[preds$lambda$time == i,], aes(fill = median), geom = "tile")+
colsc(preds$lambda$median[preds$lambda$time == i])+
ggtitle(paste("Predicted", i))#+
#ggplot()+
#gg(truth[truth$time == i,], aes(fill = exp(field)), geom = "tile")+
#ggtitle(paste("True", i))+
#colsc(exp(truth$field[truth$time == i])))
#ggsave(paste("Newupdate",i,".png",sep = "_"))
}
print(ggplot()+
gg(preds$lambda[preds$lambda$time == i,], aes(fill = median), geom = "tile")+
colsc(preds$lambda$median[preds$lambda$time == i])+
ggtitle(paste("Predicted", i))#+
#ggplot()+
#gg(truth[truth$time == i,], aes(fill = exp(field)), geom = "tile")+
#ggtitle(paste("True", i))+
#colsc(exp(truth$field[truth$time == i]))
)
#ggsave("newupdate.png")
for(i in 1:4){
print(ggplot()+
gg(preds$lambda[preds$lambda$time == i,], aes(fill = median), geom = "tile")+
colsc(preds$lambda$median[preds$lambda$time == i])+
ggtitle(paste("Predicted", i))#+
#ggplot()+
#gg(truth[truth$time == i,], aes(fill = exp(field)), geom = "tile")+
#ggtitle(paste("True", i))+
#colsc(exp(truth$field[truth$time == i]))
)
#ggsave(paste("Newupdate",i,".png",sep = "_"))
}
print(ggplot()+
gg(preds$lambda[preds$lambda$time == i,], aes(fill = sd), geom = "tile")+
colsc(preds$lambda$sd[preds$lambda$time == i])+
ggtitle(paste("Predicted", i))#+
#ggplot()+
#gg(truth[truth$time == i,], aes(fill = exp(field)), geom = "tile")+
#ggtitle(paste("True", i))+
#colsc(exp(truth$field[truth$time == i]))
)
#ggsave("newupdate.png")
for(i in 1:4){
print(ggplot()+
gg(preds$lambda[preds$lambda$time == i,], aes(fill = sd), geom = "tile")+
colsc(preds$lambda$sd[preds$lambda$time == i])+
ggtitle(paste("Predicted", i))#+
#ggplot()+
#gg(truth[truth$time == i,], aes(fill = exp(field)), geom = "tile")+
#ggtitle(paste("True", i))+
#colsc(exp(truth$field[truth$time == i]))
)
#ggsave(paste("Newupdate",i,".png",sep = "_"))
}
#priors = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
#growth = c(log(0.8),0.15),move = c(0.25,0.1),sigma = c(log(0.1),0.25))
#true K = 1000, growth =  0.8, move = 0.25, sigma = 0.1
#initial range 0.2, initial sigma = 0.01, initial pop 750
cgenfit <- readRDS("cgen_newupdate_widefine_manyiter_fitonly.RData")
setwd("~/INLAloggrowth results/24.11")
#priors = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
#growth = c(log(0.8),0.15),move = c(0.25,0.1),sigma = c(log(0.1),0.25))
#true K = 1000, growth =  0.8, move = 0.25, sigma = 0.1
#initial range 0.2, initial sigma = 0.01, initial pop 750
cgenfit <- readRDS("cgen_newupdate_widefine_manyiter_fitonly.RData")
rm(cgenfit)
#priors = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
#growth = c(log(0.8),0.15),move = c(0.25,0.1),sigma = c(log(0.1),0.25))
#true K = 1000, growth =  0.8, move = 0.25, sigma = 0.1
#initial range 0.2, initial sigma = 0.01, initial pop 750
cgenfit <- readRDS("cgen_newupdate_widefine_manyiter_fitonly.RData")
exp(cgenfit$summary.hyperpar[c(1,2,4),])
setwd("~/GitHub/INLAlogrowth-package/R")
?INLAloggrowth::simulate_loggrowth
library(INLA)
library(inlabru)
library(INLAloggrowth)
library(sf)
library(dplyr)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Gaussian", boundaries = c(0,1), debug = T,
max.edge = 0.09)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.09)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.15, npoints = 100)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.15, npoints = 750)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.15, npoints = 75)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.1, npoints = 75)
rlang::last_trace()
browser()
#'sigma = 10,initial = 75,timesteps = 3)
#'if(require("ggplot2")){
#'ggplot()+
#'gg(test.data$animal_obs)+facet_wrap(~time)+ggtitle("Observed animals")
#'ggplot()+
#'gg(test.data$animal, aes(fill = field), geom = "tile")+facet_wrap(~time)+
#'ggtitle("Underlying field")
#'}
#'
#'@export
simulate.loggrowth <- function(growth, carry.cap, movement, sigma,
initial.pop,initial.range, initial.sigma,
timesteps, npoints = NULL, obs.sd=NULL,
obs.prob = NULL,
sample.type = "LGCP", ncores = 1,
boundaries = c(0,1), debug = F,
max.edge = 0.05, nsurv = 3){
browser()
#functions needed
a.func <- function(growth,carry.cap, linpoint){
#print("Calcualting a")
return(growth*exp(linpoint)/carry.cap)
}
#growth, carry.cap, move.const = theta params to be est
#step.size = difference in time between lin points, known
#linpoint = list of linearisation point vectors
#smesh = space mesh built with fmesher, tmesh = time mesh
L.matrix <- function(growth,carry.cap,move.const,step.size, linpoint, smesh, tmesh){
#print("Calcualting Lmat")
ns <- smesh$n
nt <- tmesh$n
a<- a.func(growth,carry.cap, linpoint)
a[1:ns] <- 1
a.mat <- Matrix::Diagonal(ns*nt,a)
subdiag <- Matrix::bandSparse(nt*ns, k = -ns, diagonals = list(rep(-1/step.size, (nt - 1)*ns)))
fem.matrices <- fmesher::fm_fem(smesh)
CinvG <- Matrix::solve(fem.matrices$c1, fem.matrices$g1)
main.diag <- Matrix::kronecker(Matrix::Diagonal(nt, c(0,rep(1, nt-1))),
Matrix::Diagonal(ns, 1/(step.size))+ move.const*CinvG)
#print(diag(main.diag + subdiag + a.mat))
return(Matrix::drop0(main.diag + subdiag + a.mat, tol = 1e-100))
}
r.vector <- function(growth,carry.cap,move.const,linpoint,grad){
mag.grad.sq <- rowSums(grad*grad) #magnitude squared
return(growth*exp(linpoint)*(linpoint-1)/carry.cap+ growth - move.const*mag.grad.sq )
}
interpret.theta = function() {
return(list(growth = theta[1L],
carry.cap = exp(theta[2L]),
move.const = theta[3L],
sigma = exp(theta[4L])))
}
Q = function(){
#browser()
#print("Calcualting Q")
par = interpret.theta()
#print(par)
Lmat = L.matrix(par$growth, par$carry.cap, par$move.const,step.size, linpoint, smesh, tmesh)
noiseonly = Matrix::Diagonal(smesh$n*(tmesh$n-1), 1/(par$sigma*step.size)**2)
noise.precision = Matrix::bdiag(list(prior.precision, noiseonly))
output = Matrix::crossprod(Lmat, noise.precision %*% Lmat)
#print(output[smesh$n:(smesh$n +10),smesh$n:(smesh$n +10)])
return(Matrix::drop0(output, 1e-100))
}
mu = function(){
#browser()
#print("Calcualting mu")
#if(class(theta)!="numeric"){
#  theta <- initial()
#}
par = interpret.theta()
#print(par)
Lmat = L.matrix(par$growth, par$carry.cap, par$move.const, step.size, linpoint, smesh, tmesh)
r = c(prior.mean, r.vector(par$growth, par$carry.cap, par$move.const, linpoint, grad)[-(1:smesh$n)])
Lmat_det <- Matrix::det(Lmat)
if(!is.nan(Lmat_det)) {
if(abs(Lmat_det) <= .Machine$double.eps){ #if close to singular use
#print(det(crossprod(Lmat,Lmat)))
mu = Matrix::solve(crossprod(Lmat,Lmat),crossprod(Lmat,r)) #more stable form of solve(lmat,r)
mu= as.vector(mu)
print("Trick version")
}else{
mu = Matrix::solve(Lmat,r)
#print("Default Solve")
}}else{
print("There's some NaNs going on?")
mu = NA
}
#print(mean(mu))
return(mu)
}
#set up for simulation
corners <- c(boundaries[1] - 2*initial.range, boundaries[2]+2*initial.range)
bnd_extended <- inlabru::spoly(data.frame(easting = c(corners[1], corners[2],corners[2],corners[1]),
northing = c(corners[1], corners[1],corners[2],corners[2])))
smesh <- fmesher::fm_mesh_2d_inla(boundary = bnd_extended, max.edge = max.edge)
tmesh <- fmesher::fm_mesh_1d(loc = 1:timesteps)
step.size <- 1
if(debug) print("set up finished, generating first year")
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(initial.range, initial.sigma)))
prior.mean <- log(initial.pop) + inla.qsample(1, initial_Q)[,1]
if(debug){
print("Defining model")
}
#components needed for model
initial.growth <- growth
initial.carry.cap <- log(carry.cap)
initial.move.const <- movement
initial.log.sigma <- log(sigma)
theta <- c(initial.growth, initial.carry.cap, initial.move.const, initial.log.sigma)
linpoint <- log(logit.nest(exp(prior.mean), growth, carry.cap, tmesh$n)$x)
grad <- gradient_of_linpoint(linpoint, smesh, tmesh)#
prior.precision <- initial_Q
if(debug) print("Calculating precision")
Q_mat <-Q()
if(debug) print("Calculating mean")
mu_mat <- mu()
#generate field
if(debug) print("generating field")
field <- data.frame(field = inla.qsample(1, Q_mat, mu = mu_mat)[, 1])
field$time <- rep(1:timesteps, each = smesh$n)
expand_for_plot <- function(i){
animal_tempsf <- expand.grid(
easting = seq(corners[1],corners[2], by = 0.01),
northing = seq(corners[1],corners[2], by = 0.01))
animal_tempsf <- dplyr::mutate(sf::st_as_sf(animal_tempsf, coords = c("easting", "northing")),
time = i)
animal_tempsf$field <- fmesher::fm_evaluate(
smesh,
loc = animal_tempsf,
field = field$field[field$time == i])
return(animal_tempsf)
}
expanded <- parallel::mclapply(1:timesteps, expand_for_plot,  mc.cores = ncores)
animal <- do.call(rbind, expanded)
bnd_inner <- sf::st_as_sf(inlabru::spoly(data.frame(easting = c(boundaries[1],boundaries[2],boundaries[2],boundaries[1]),
northing = c(boundaries[1], boundaries[1], boundaries[2], boundaries[2]))))
if(debug) print("Sampling")
if(sample.type == "Normal"){
points.to.sample <- sample(unique(sf::st_filter(animal,bnd_inner)$geometry),
npoints)
animal_obs <- filter(animal, geometry %in% points.to.sample) %>%
dplyr::mutate(obs = rnorm(npoints*(tmesh$n), field, obs.sd))
} else if(sample.type == "Bernoulli"){
points.to.sample <- sample(unique(sf::st_filter(animal,bnd_inner)$geometry),
npoints)
animal_obs <- filter(animal, geometry %in% points.to.sample) %>%
dplyr::mutate(obs = rbinom(npoints*(tmesh$n), 1, plogis(obs.prob + field)),
survey = rep(1, npoints*tmesh$n))
if(nsurv>1){
for(i in 2:nsurv){
animal_obs <- rbind(animal_obs,
filter(animal, geometry %in% points.to.sample) %>%
dplyr::mutate(obs = rbinom(npoints*(tmesh$n), 1, plogis(obs.prob+field)),
survey = rep(i, npoints*tmesh$n)))
}
}
}else if(sample.type == "LGCP"){
#field$field[field$field <0] <- 0
simulate_obs <- function(i){
samp_animal <- inlabru::sample.lgcp(smesh,
loglambda = field$field[field$time == i],
samplers = bnd_inner)
samp_animal <- sf::st_as_sf(samp_animal, coords = c("x","y"))
samp_animal_df <- dplyr::mutate(samp_animal, time = i)
return(samp_animal_df)
}
observations <- parallel::mclapply(1:timesteps, simulate_obs,  mc.cores =  ncores)
animal_obs <- do.call(rbind, observations)
#remove edge effects
#animal_obs <- st_as_sf(animal_obs, coords = c("x","y"))
} else{
print("Sampling type not recognised")
animal_obs = 0
}
return(list(animal = animal,field = field,
animal_obs = animal_obs))
}
out.lgcp <- simulate.loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.2, npoints = 5)
obs.sd
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.2, npoints = 5, obs.sd = 0.1)
summary(out.lgcp)
summary(out.lgcp$animal_obs)
bnd <- spoly(data.frame(easting = c(0,1,1,0), northing = c(0,0,1,1)))
mesh_obs <- fm_mesh_2d(boundary = bnd,
max.edge = c(0.075,0.25), offset = c(-0.1, 0.75))
bnd <- st_as_sf(bnd)
ggplot()+gg(out.lgcp$animal, aes(fill = exp(field)), geom = "tile")+facet_wrap(~time)
ggplot()+gg(out.lgcp$animal_obs, aes(colour = exp(obs)))+facet_wrap(~time)+scale_color_continuous(type = "viridis")
mesh_time <- fm_mesh_1d(loc = 1:4)
matern <- inla.spde2.pcmatern(mesh_obs,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.05, 0.05))
cmp <- obs ~ smooth(geometry, model = matern) +
initial(1,model = "linear", mean.linear = log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,])))-1
fit0 <- bru(cmp, out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,],domain = list(geometry = mesh_obs),
family = "gaussian",samplers = bnd)
print(summary(fit0))
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 1000, movement = 0.25, sigma = 0.1,
initial.pop = 750, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.09, npoints = 150, obs.sd = 0.05)
ggplot()+gg(out.lgcp$animal, aes(fill = exp(field)), geom = "tile")+facet_wrap(~time)
ggplot()+gg(out.lgcp$animal, aes(fill = exp(field)), geom = "tile")+facet_wrap(~time)+scale_fill_continuous(type = "viridis")
bnd <- spoly(data.frame(easting = c(0,1,1,0), northing = c(0,0,1,1)))
mesh_obs <- fm_mesh_2d(boundary = bnd,
max.edge = c(0.075,0.25), offset = c(-0.1, 0.75))
bnd <- st_as_sf(bnd)
mesh_time <- fm_mesh_1d(loc = 1:4)
matern <- inla.spde2.pcmatern(mesh_obs,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.05, 0.05))
cmp <- obs ~ smooth(geometry, model = matern) +
initial(1,model = "linear", mean.linear = log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,])))-1
fit0 <- bru(cmp, out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,],domain = list(geometry = mesh_obs),
family = "gaussian",samplers = bnd)
print(summary(fit0))
exp(6.621)
#print(summary(fit0))
#Find fitted values on mesh points
#library(stringr)
index <- min(which(stringr::str_sub(rownames(fit0$summary.fitted.values),8,8)!= "A"))
n.nodes <- fit0$misc$configs$nconfig
nodes <- data.frame(log.prob=rep(NA,n.nodes))
mat_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- fit0$misc$configs$config[[i]]$log.posterior
mat_list[[i]] <- fit0$misc$configs$config[[i]]$Q[1:mesh_obs$n,1:mesh_obs$n]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
Q <- Reduce("+", Map(function(m,w) w*m, mat_list,nodes$weight.prob))
initial.precision <-Q#Diagonal(mesh_obs$n,
initial.precision <-Diagonal(mesh_obs$n,
1/((fit0$summary.fixed$sd**2)+(fit0$summary.fitted.values$sd[index-1 +1:mesh_obs$n]**2)))%*%Q
#fit other years
priors <- list(cc = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
growth = c(log(0.8),0.1),move = c(0.25,0.1),sigma = c(log(0.1),0.1))
print(priors)
summary(exp(fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n]))
initial.linpoint <- log(logit.nest(exp(fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n]), 0.8, 1000,4)$x)
summary(exp(initial.linpoint))
plot(exp(initial.linpoint))
out.lgcp$animal_obs <- mutate(out.lgcp$animal_obs, y = obs)
iterated.fit.lgcp <- iterate.cgeneric.fit.gaussian(data = out.lgcp$animal_obs, smesh = mesh_obs, tmesh = mesh_time,
samplers = bnd,prior.mean = fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n],
prior.precision = initial.precision, priors = priors,
max.iter = 100,gamma = 0.5,
stop.crit = 0.005,
initial.linpoint = initial.linpoint, initial.growth = log(0.8),
initial.log.sigma = log(0.1),
initial.move.const = 0.25,
initial.carry.cap = log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,])),
saveall = F, options = list(verbose = T))
detach("package:INLA", unload = TRUE)
detach("package:inlabru", unload = TRUE)
detach("package:INLAloggrowth", unload = TRUE)
detach("package:inlabru", unload = TRUE)
detach("package:INLA", unload = TRUE)
#remove.packages("INLAloggrowth")
remotes::install_github("ljb34/INLAlogisticgrowth@update-rule", force = F)
roxygen2::roxygenise()
setwd("~/GitHub/INLAlogrowth-package")
roxygen2::roxygenise()
detach("package:inlabru", unload = TRUE)
library(INLAloggrowth)
library(INLAloggrowth)
detach("INLAloggrowth")
detach(INLAloggrowth)
