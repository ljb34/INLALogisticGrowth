prior.mean = prior.mean, priors = priors,
prior.precision = prior.precision,
grad = grad,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma)
class(the_model) <- c("log_growth_model", class(the_model))
the_model[["smesh"]] <- smesh
the_model[["tmesh"]] <- tmesh
return(the_model)
}
#'@name bru_get_mapper.log_growth_model
#' @title Mapper function for internal use
#' @export
bru_get_mapper.log_growth_model <- function(model, ...) {
stopifnot(requireNamespace("inlabru"))
inlabru::bru_mapper_multi(list(
space = inlabru::bru_mapper(model[["smesh"]]),
time = inlabru::bru_mapper(model[["tmesh"]], indexed = TRUE)
))
}
#'Fit a logistic growth model with LGCP observations
#' @description
#' Iteratively fits the spatial logistic growth model.
#' @param data spatial dataframe  observations
#' @param smesh spatial mesh created with \code{fm_mesh_2d_inla}
#' @param tmesh mesh over equally spaced time points created with \code{fm_mesh_1d}
#' @param samplers sampling area for supplying to inlabru
#' @param prior.mean estimated mean for first year of data. Helper function for calculating coming soon
#' @param prior.precision uncertainty for estimated mean of first year of data. Helper function for calculating coming soon
#' @param max.iter maximum iterations to attempt
#' @param gamma dampening parameter for update rule
#' @param stop.crit stopping criteria for linearisation point update rule. Stop updating if mean(abs(new_linearisation_point-old_linearisation_point))<=stop.crit
#' @param priors named list of prior parameters, named \code{cc} (carrying capacity), \code{growth}, \code{move}, \code{sigma}.
#' Each is a two element vector containing the mean and variance for parameter.
#' @param initial.linpoint Optional. Starting guess for the linearisation point. If NULL, will be estimated within function
#' @param initial.growth,initial.carry.cap,initial.move.const,initial.log.sigma Starting values for the growth,
#' \emph{log} carrying capacity, movement constant and \emph{log} standard deviation
#' @param verbose logical supplied to INLA
#' @returns list containing final model fit, number of iterations \code{n}, matrix of all past linearisation points and list of all past model fits.
#'@export
iterate.fit.lgcp <- function(data, smesh, tmesh, samplers,prior.mean,
prior.precision, max.iter = 100,gamma = 0.5,stop.crit = 0.05,
priors = NULL, initial.linpoint = NULL, initial.growth=NULL,
initial.carry.cap=NULL, initial.move.const =NULL, initial.log.sigma =NULL,
verbose = F, saveall = T){
#browser()
step.size = (tmesh$interval[2]-tmesh$interval[1])/(tmesh$n-1) #calculate step size. -1 in denom due to fence post problem
if(is.null(initial.linpoint)){
initial.linpoint <- log(logit.nest(exp(prior.mean), exp(initial.growth), initial.carry.cap, tmesh$n)$x)
}
if(!is.matrix(initial.linpoint)) initial.linpoint <- as.matrix(initial.linpoint, ncol = 1)
#Set up initial model
fit.list <- list()
log_growth_model <- define.loggrow.model(linpoint = initial.linpoint,
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma)
fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose, control.inla = list(control.vb=list(emergency=30))))
if(saveall){
fit.list[[1]]<-fit
}else{
fit.list <- fit
}
print("First fitting finished")
n.nodes <- fit$misc$configs$nconfig
nodes <- data.frame(log.prob=rep(NA,n.nodes))
#mat_list <- list()
mean_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- fit$misc$configs$config[[i]]$log.posterior
#mat_list[[i]] <- fit$misc$configs$config[[i]]$Q[1:(smesh$n*tmesh$n), 1:(smesh$n*tmesh$n)]
mean_list[[i]] <- fit$misc$configs$config[[i]]$improved.mean[1:(smesh$n*tmesh$n)]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
#Old rule- in theory faster but gives some extreme changes
#P <- Reduce("+", Map(function(m, w) m * w, mat_list, nodes$weight.prob))
#weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
#b <- Reduce("+", Map(function(m,w) m%*%w, mat_list,weighted.means))
#new.linpoint <- (1-gamma)*initial.linpoint +gamma*solve(P,b)
#New update rule
weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
new.mean <- Reduce("+", weighted.means)
new.linpoint <- (1-gamma)*initial.linpoint +gamma*new.mean
print("Calcualted new linpoint")
lp.mat <- cbind(initial.linpoint,new.linpoint)
n <- 2
#print(fit$summary.hyperpar$mean)
while(n < max.iter & mean(abs(lp.mat[,n]-lp.mat[,n-1]))>stop.crit){
log_growth_model <- define.loggrow.model(linpoint = as.vector(new.linpoint),
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma)
print("Defined new model")
fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose, control.inla = list(control.vb=list(emergency=30))))
print(paste("Fitted new model", n))
if(saveall){
fit.list[[n]]<-fit
}else{
fit.list <- fit
}
n.nodes <- fit$misc$configs$nconfig
if(!is.numeric(n.nodes)){
print("Failed to fit, trying again")
fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose, control.inla = list(control.vb=list(emergency=300))))
n.nodes <- fit$misc$configs$nconfig
if(!is.numeric(fit$misc$configs$nconfig)){
print("Failed again, returning model output")
return(list(new.linpoint = new.linpoint,fit = fit, past.linpoints = lp.mat, fit.list = fit.list))
}
if(saveall){
fit.list[[n]]<-fit
}else{
fit.list <- fit
}
}
nodes <- data.frame(log.prob=rep(NA,n.nodes))
#mat_list <- list()
mean_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- fit$misc$configs$config[[i]]$log.posterior
#mat_list[[i]] <- fit$misc$configs$config[[i]]$Q[1:(smesh$n*tmesh$n),1:(smesh$n*tmesh$n)]
mean_list[[i]] <- fit$misc$configs$config[[i]]$improved.mean[1:(smesh$n*tmesh$n)]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
#P <- Reduce("+", Map(function(m, w) m * w, mat_list, nodes$weight.prob))
#weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
#b <- Reduce("+", Map(function(m,w) m%*%w, mat_list,weighted.means))
#new.linpoint <- (1-gamma)*lp.mat[,n] +gamma*solve(P,b)
#New update rule
weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
new.mean <- Reduce("+", weighted.means)
new.linpoint <- (1-gamma)*lp.mat[,n-1] +gamma*new.mean
lp.mat <- cbind(lp.mat,new.linpoint)
print("Updated linpoint")
n <- n+1
}
log_growth_model <- define.loggrow.model(linpoint = as.vector(new.linpoint),
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma)
print("Defined final model")
final.fit <- bru(geometry + time ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n) -1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "cp", options = list(verbose = verbose))
return(list(fit = final.fit, n = n, linpoints = lp.mat, fit_list = fit.list))
}
iterated.fit.lgcp <- iterate.fit.lgcp(data = out.lgcp$animal_obs, smesh = mesh_obs, tmesh = mesh_time,
samplers = bnd,prior.mean = rep(fit0$summary.fixed$mean,mesh_obs$n)+fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n],
prior.precision = initial.precision, priors = priors,
max.iter = 100,gamma = 0.2,
stop.crit = 0.01,initial.growth = log(0.8),
initial.log.sigma = log(0.1),
initial.move.const = 0.25,
initial.linpoint = initial.linpoint, initial.carry.cap = log(500),
verbose = T, saveall = F)
c(initial.growth, initial.carry.cap,
initial.move.const, initial.log.sigma)
setwd("~/GitHub/Spatial-Population-Dynamics/Final code + results")
library(inlabru)
library(INLA)
library(sf)
library(tidyverse)
library(INLAspacetime)
library(latex2exp)
colsc <- function(...) {
scale_fill_gradientn(
colours = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
limits = range(..., na.rm = TRUE)
)
}
fit <- readRDS("rerun_diff_b0_narrow_fit_update.RData")
preds <- readRDS("rerun_diff_b0_narrow_preds.RData")
AR1fit <- readRDS("AR1_diff_fit.RData")
AR1preds <- readRDS("AR1_diff_preds.RData")
iidpreds <- readRDS("iid_diff_preds.RData")
iidfit <- readRDS("iid_diff_fit.RData")
sim <- readRDS("diff_b0_narrow_sim.RData")
truth <- st_filter(sim$animal, st_as_sf(spoly(data.frame(easting = c(0, 10, 10, 0), northing = c(0, 0, 10, 10)))))
truth$type <- "Truth"
times <- c(0:2, 4,7,10)
difftimes <- c(0:2, seq(4,10,by = 2))
for(i in c(1:4,6,7)){
preds[[i]] <- filter(preds[[i]], time == difftimes[i])
preds[[i]]$type <- "Diffusion"
}
for(i in 1:11){
AR1preds[[i]]<- filter(AR1preds[[i]], time == i-1)
AR1preds[[i]]$type <- "AR1"
iidpreds[[i]]<- filter(iidpreds[[i]], time == i-1)
iidpreds[[i]]$type <- "IID"
}
combpreds <- rbind(rbind(preds[[1]],preds[[2]], preds[[3]], preds[[4]], preds[[6]],
preds[[7]]),
do.call(rbind, AR1preds),
do.call(rbind, iidpreds))
ggplot()+
gg(combpreds[combpreds$time %in% times & combpreds$type != "Diffusion",], aes(fill = median), geom = "tile")+
gg(truth[truth$time %in% times,], aes(fill = field), geom = "tile")+
facet_grid(rows = vars(type), cols = vars(time))+
#facet_wrap(~time)+
colsc(truth$field, combpreds$mean)+theme_bw(base_size = 18)
estimates <- rbind(select(AR1fit$summary.fixed,!kld),AR1fit$summary.hyperpar,
select(iidfit$summary.fixed,!kld), iidfit$summary.hyperpar,
select(fit$summary.fixed, !kld))
colsc <- function(...) {
scale_fill_gradientn(
colours = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
limits = range(..., na.rm = TRUE)
)
}
AR1fit$summary.fixed$parameter <- row.names(AR1fit$summary.fixed)
iidfit$summary.fixed$parameter <- row.names(iidfit$summary.fixed)
fit$summary.fixed$parameter <- row.names(fit$summary.fixed)
fit$summary.fixed$type <- "Diffusion"
AR1fit$summary.hyperpar$parameter <- row.names(AR1fit$summary.hyperpar)
iidfit$summary.hyperpar$parameter <- row.names(iidfit$summary.hyperpar)
diff.params <- data.frame(parameter = c("Range for smooth", "Time Range", "Stdev for smooth"),
mean = gammas2params(fit$summary.hyperpar$mean, 2,2,0),
type = "Diffusion",
`0.025quant` = gammas2params(fit$summary.hyperpar$`0.975quant`, 2,2,0),
`0.975quant` =gammas2params(fit$summary.hyperpar$`0.025quant`, 2,2,0))
diff.params[diff.params$parameter == "Stdev for smooth", c(2,4,5)]<- exp(diff.params[diff.params$parameter == "Stdev for smooth", c(2,4,5)])
names(diff.params) <- c("parameter", "mean", "type", "0.025quant", "0.975quant")
true.params <- data.frame(parameter = c("r", "kchange", "k0",
"initchange", "init0", "Stdev for smooth",
"Range for smooth", "Time Range"),
mean = c(0.6, 2.5, -1, 1.5, -1.5,1,4, 3),
type = "Truth", `0.025quant`=NA,`0.975quant`=NA
)
names(true.params) <- c("parameter", "mean", "type", "0.025quant", "0.975quant")
estimates <- rbind(select(AR1fit$summary.fixed,!kld),AR1fit$summary.hyperpar,
select(iidfit$summary.fixed,!kld), iidfit$summary.hyperpar,
select(fit$summary.fixed, !kld))
AR1fit$summary.fixed$parameter <- row.names(AR1fit$summary.fixed)
iidfit$summary.fixed$parameter <- row.names(iidfit$summary.fixed)
fit$summary.fixed$parameter <- row.names(fit$summary.fixed)
fit$summary.fixed$type <- "Diffusion"
AR1fit$summary.hyperpar$parameter <- row.names(AR1fit$summary.hyperpar)
iidfit$summary.hyperpar$parameter <- row.names(iidfit$summary.hyperpar)
diff.params <- data.frame(parameter = c("Range for smooth", "Time Range", "Stdev for smooth"),
mean = gammas2params(fit$summary.hyperpar$mean, 2,2,0),
type = "Diffusion",
`0.025quant` = gammas2params(fit$summary.hyperpar$`0.975quant`, 2,2,0),
`0.975quant` =gammas2params(fit$summary.hyperpar$`0.025quant`, 2,2,0))
diff.params[diff.params$parameter == "Stdev for smooth", c(2,4,5)]<- exp(diff.params[diff.params$parameter == "Stdev for smooth", c(2,4,5)])
names(diff.params) <- c("parameter", "mean", "type", "0.025quant", "0.975quant")
true.params <- data.frame(parameter = c("r", "kchange", "k0",
"initchange", "init0", "Stdev for smooth",
"Range for smooth", "Time Range"),
mean = c(0.6, 2.5, -1, 1.5, -1.5,1,4, 3),
type = "Truth", `0.025quant`=NA,`0.975quant`=NA
)
names(true.params) <- c("parameter", "mean", "type", "0.025quant", "0.975quant")
estimates <- rbind(select(AR1fit$summary.fixed,!kld),AR1fit$summary.hyperpar,
select(iidfit$summary.fixed,!kld), iidfit$summary.hyperpar,
select(fit$summary.fixed, !kld))
library(inlabru)
library(INLA)
library(sf)
library(tidyverse)
library(INLAspacetime)
library(latex2exp)
colsc <- function(...) {
scale_fill_gradientn(
colours = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
limits = range(..., na.rm = TRUE)
)
}
fit <- readRDS("rerun_diff_b0_narrow_fit_update.RData")
preds <- readRDS("rerun_diff_b0_narrow_preds.RData")
bru_convergence_plot(fit)
summary(fit)
AR1fit$summary.fixed$parameter <- row.names(AR1fit$summary.fixed)
iidfit$summary.fixed$parameter <- row.names(iidfit$summary.fixed)
fit$summary.fixed$parameter <- row.names(fit$summary.fixed)
fit$summary.fixed$type <- "Diffusion"
AR1fit$summary.hyperpar$parameter <- row.names(AR1fit$summary.hyperpar)
iidfit$summary.hyperpar$parameter <- row.names(iidfit$summary.hyperpar)
diff.params <- data.frame(parameter = c("Range for smooth", "Time Range", "Stdev for smooth"),
mean = gammas2params(fit$summary.hyperpar$mean, 2,2,0),
type = "Diffusion",
`0.025quant` = gammas2params(fit$summary.hyperpar$`0.975quant`, 2,2,0),
`0.975quant` =gammas2params(fit$summary.hyperpar$`0.025quant`, 2,2,0))
diff.params[diff.params$parameter == "Stdev for smooth", c(2,4,5)]<- exp(diff.params[diff.params$parameter == "Stdev for smooth", c(2,4,5)])
names(diff.params) <- c("parameter", "mean", "type", "0.025quant", "0.975quant")
true.params <- data.frame(parameter = c("r", "kchange", "k0",
"initchange", "init0", "Stdev for smooth",
"Range for smooth", "Time Range"),
mean = c(0.6, 2.5, -1, 1.5, -1.5,1,4, 3),
type = "Truth", `0.025quant`=NA,`0.975quant`=NA
)
names(true.params) <- c("parameter", "mean", "type", "0.025quant", "0.975quant")
dim(fit$summary.fixed)
dim(AR1fit$summary.fixed)
head(fit$summary.fixed)
head(AR1fit$summary.fixed)
AR1fit$summary.fixed$type <- "AR1"
AR1fit$summary.hyperpar$type <- "AR1"
estimates <- rbind(select(AR1fit$summary.fixed,!kld),AR1fit$summary.hyperpar,
select(iidfit$summary.fixed,!kld), iidfit$summary.hyperpar,
select(fit$summary.fixed, !kld))
dim(AR1fit$summary.fixed)
dim(iidfit$summary.fixed)
iidfit$summary.fixed$type <- "IID"
iidfit$summary.hyperpar$type <- "IID"
estimates <- rbind(select(AR1fit$summary.fixed,!kld),AR1fit$summary.hyperpar,
select(iidfit$summary.fixed,!kld), iidfit$summary.hyperpar,
select(fit$summary.fixed, !kld))
estimates <- rbind(select(estimates, c(mean,`0.025quant`,`0.975quant`,type, parameter)),
true.params, diff.params)
param_names <- list("k0"=TeX("$k_0$"), "kchange" = TeX("$k_1$"), "init0" = TeX("$\\beta_0$"),
"initchange"=TeX("$\\beta_1$"), "r"=TeX("$\\alpha$"), "Range for smooth" = "Spatial Range",
"Stdev for smooth" = TeX("$\\sigma$"), "GroupRho for smooth" = "AR1 Correlation",
"Time Range" = "Temporal Range")
param_labeller <- function(variable,value){
return(param_names[value])
}
estimates %>% filter(parameter != "GroupRho for smooth"&
type!="Truth")%>%
ggplot()+
geom_errorbar(aes(ymin = `0.025quant`,ymax = `0.975quant`,x = type,
colour = type), linewidth = 1)+
geom_point(aes(y = mean, x = type, colour = type), size = 3)+
geom_hline(data =filter(true.params, parameter != "GroupRho for smooth"), aes(yintercept = mean), linetype = "longdash")+
theme_minimal(base_size = 18)+scale_color_manual(values = c("darkgoldenrod2","dodgerblue","seagreen"))+
#scale_shape_manual(values = c(15,17,18,19))+
facet_wrap(~parameter, scales = "free", nrow = 2, labeller = param_labeller)+
xlab("Spatio-Temporal Effect")+ylab("Posterior")+guides(colour = "none")
return(param_names[df$parameter])
param_labeller <- function(df) {
return(param_names[df$parameter])
}
estimates %>% filter(parameter != "GroupRho for smooth"&
type!="Truth")%>%
ggplot()+
geom_errorbar(aes(ymin = `0.025quant`,ymax = `0.975quant`,x = type,
colour = type), linewidth = 1)+
geom_point(aes(y = mean, x = type, colour = type), size = 3)+
geom_hline(data =filter(true.params, parameter != "GroupRho for smooth"), aes(yintercept = mean), linetype = "longdash")+
theme_minimal(base_size = 18)+scale_color_manual(values = c("darkgoldenrod2","dodgerblue","seagreen"))+
#scale_shape_manual(values = c(15,17,18,19))+
facet_wrap(~parameter, scales = "free", nrow = 2, labeller = param_labeller)+
xlab("Spatio-Temporal Effect")+ylab("Posterior")+guides(colour = "none")
estimates %>% filter(parameter != "GroupRho for smooth"&
type!="Truth")%>%
ggplot()+
geom_errorbar(aes(ymin = `0.025quant`,ymax = `0.975quant`,x = type,
colour = type), linewidth = 1)+
geom_point(aes(y = mean, x = type, colour = type), size = 3)+
geom_hline(data =filter(true.params, parameter != "GroupRho for smooth"), aes(yintercept = mean), linetype = "longdash")+
theme_minimal(base_size = 18)+scale_color_manual(values = c("darkgoldenrod2","dodgerblue","seagreen"))+
#scale_shape_manual(values = c(15,17,18,19))+
facet_wrap(~parameter, scales = "free", nrow = 2, labeller = as_labeller(param_names))+
xlab("Spatio-Temporal Effect")+ylab("Posterior")+guides(colour = "none")
estimates %>% filter(parameter %in% c("Range for smooth", "Time Range"))
estimates
param_names <- c("k0"=TeX("$k_0$"), "kchange" = TeX("$k_1$"), "init0" = TeX("$\\beta_0$"),
"initchange"=TeX("$\\beta_1$"), "r"=TeX("$\\alpha$"), "Range for smooth" = "Spatial Range",
"Stdev for smooth" = TeX("$\\sigma$"), "GroupRho for smooth" = "AR1 Correlation",
"Time Range" = "Temporal Range")
estimates %>% filter(parameter != "GroupRho for smooth"&
type!="Truth")%>%
ggplot()+
geom_errorbar(aes(ymin = `0.025quant`,ymax = `0.975quant`,x = type,
colour = type), linewidth = 1)+
geom_point(aes(y = mean, x = type, colour = type), size = 3)+
geom_hline(data =filter(true.params, parameter != "GroupRho for smooth"), aes(yintercept = mean), linetype = "longdash")+
theme_minimal(base_size = 18)+scale_color_manual(values = c("darkgoldenrod2","dodgerblue","seagreen"))+
#scale_shape_manual(values = c(15,17,18,19))+
facet_wrap(~parameter, scales = "free", nrow = 2, labeller = as_labeller(param_names))+
xlab("Spatio-Temporal Effect")+ylab("Posterior")+guides(colour = "none")
setwd("~/INLAloggrowth results/Fixed K")
fit <- readRDS("SLURMfit.RData")
summary(fit)
exp(fit$summary.hyperpar)
data <- readRDS("SLURMdata.RData")
readRDS("fixK_slurm_standard_preds.RData")
preds <- readRDS("fixK_slurm_standard_preds.RData")
mesh <- fit$bru_info$model$effects$loggrow$mapper$mappers$mapper$mappers$main$mappers$space$mesh
mesh$n
library(ggplot2)
library(inlabru)
ggplot()+
gg(preds$lambda, aes(fill = mean), geom = "tile")+
facet_Wrap(~time)
ggplot()+
gg(preds$lambda, aes(fill = mean), geom = "tile")+
facet_wrap(~time)
colsc <- function(...) {
scale_fill_gradientn(
colours = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
limits = range(..., na.rm = TRUE)
)
}
ggplot()+
gg(preds$lambda, aes(fill = mean), geom = "tile")+
facet_wrap(~time)+colsc(preds$lambda, exp(data$animal$field))
ggplot()+
gg(preds$lambda, aes(fill = mean), geom = "tile")+
facet_wrap(~time)+colsc(preds$lambda$mean, exp(data$animal$field))
ggplot()+
gg(preds$lambda, aes(fill = mean), geom = "tile")+
facet_wrap(~time)+colsc(exp(data$animal$field))
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(preds$lambda$median, exp(data$animal$field))
ggplot(preds$lambda)+
geom_histogram(aes(x = median))+facet_wrap(~time)
which(preds$lambda$median > 500)
ggplot()+
gg(data$animal, aes(fill = exp(field)), geom = "tile")+
facet_wrap(~time)
ggplot()+
gg(data$animal, aes(fill = exp(field)), geom = "tile")+
facet_wrap(~time)+colsc(preds$lambda$median, exp(data$animal$field))
min(c(preds$lambda$median, exp(data$animal$field)))
min(c(preds$lambda$median, exp(data$animal$field)), na.rm = T)
library(sf)
truth <- st_filter(data$animal, bnd)
min(c(preds$lambda$median, exp(truth$field)), na.rm = T)
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))
ggplot()+
gg(truth, aes(fill = exp(field)), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+
ggtitle("Truth")+
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+ggtitle("Predicted")
library(patchwork)
ggplot()+
gg(truth, aes(fill = exp(field)), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+
ggtitle("Truth")+
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+ggtitle("Predicted")
setwd("~/GitHub/INLAlogrowth-package")
roxygen2::roxygenise()
ggplot()+
gg(truth, aes(fill = exp(field)), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+
ggtitle("Truth")+
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+ggtitle("Predicted")+
ggplot()+
gg(preds$lambda, aes(fill = sd), geom = "tile")+
facet_wrap(~time)+colsc(preds$lambda$sd)+ggtitle("SD")
ggplot()+
gg(preds$lambda, aes(fill = sd), geom = "tile")+
facet_wrap(~time)+colsc(preds$lambda$sd)+ggtitle("SD")
ggplot()+
gg(truth, aes(fill = exp(field)), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+
ggtitle("Truth")+
ggplot()+
gg(preds$lambda, aes(fill = median), geom = "tile")+
facet_wrap(~time)+colsc(c(49,500))+ggtitle("Predicted")+
ggplot()+
gg(preds$lambda, aes(fill = sd), geom = "tile")+
facet_wrap(~time)+colsc(preds$lambda$sd)+ggtitle("SD")
ggsave("It works.png")
nrow(data$animal_obs)
exp(fit$summary.hyperpar)
setwd("~/GitHub/INLAlogrowth-package/R")
rm(ls = list())
rm(ls())
rm(list = ls())
roxygen2::roxygenise()
setwd("~/GitHub/INLAlogrowth-package")
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::document()
roxygen2::roxygenise()
devtools::document()
devtools::document()
