rm(list = ls())
options(repos = c(CRAN = "https://cloud.r-project.org"))
library(INLA)
#remove.packages("INLAloggrowth")
remotes::install_github("ljb34/INLAlogisticgrowth@update-rule", force = F)
library(inlabru)
library(INLAloggrowth)
library(sf)
library(dplyr)
out.lgcp <- simulate_loggrowth(growth = 0.8, carry.cap = 500, movement = 0.25, sigma = 0.1,
initial.pop = 250, initial.range = 0.3, initial.sigma=0.01,
timesteps = 4,sample.type = "Normal", boundaries = c(0,1), debug = T,
max.edge = 0.09, npoints = 150, obs.sd = 0.05)
bnd <- spoly(data.frame(easting = c(0,1,1,0), northing = c(0,0,1,1)))
mesh_obs <- fm_mesh_2d(boundary = bnd,
max.edge = c(0.075,0.25), offset = c(-0.1, 0.75))
bnd <- st_as_sf(bnd)
mesh_time <- fm_mesh_1d(loc = 1:4)
matern <- inla.spde2.pcmatern(mesh_obs,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.05, 0.05))
cmp <- obs ~ smooth(geometry, model = matern) +
initial(1,model = "linear")-1
fit0 <- bru(cmp, out.lgcp$animal_obs[out.lgcp$animal_obs$time == 1,],domain = list(geometry = mesh_obs),
family = "gaussian",samplers = bnd)
print(summary(fit0))
exp(5)
exp(5.527)
#print(summary(fit0))
#Find fitted values on mesh points
#library(stringr)
index <- min(which(stringr::str_sub(rownames(fit0$summary.fitted.values),8,8)!= "A"))
n.nodes <- fit0$misc$configs$nconfig
nodes <- data.frame(log.prob=rep(NA,n.nodes))
mat_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- fit0$misc$configs$config[[i]]$log.posterior
mat_list[[i]] <- fit0$misc$configs$config[[i]]$Q[1:mesh_obs$n,1:mesh_obs$n]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
Q <- Reduce("+", Map(function(m,w) w*m, mat_list,nodes$weight.prob))
initial.precision <-Diagonal(mesh_obs$n,
1/((fit0$summary.fixed$sd**2)+(fit0$summary.fitted.values$sd[index-1 +1:mesh_obs$n]**2)))%*%Q
#fit other years
priors <- list(cc = c(log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,]))-0.5*0.1*0.1,0.1),
growth = c(log(0.8),0.1),move = c(0.25,0.1),sigma = c(log(0.1),0.1))
print(priors)
summary(exp(fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n]))
initial.linpoint <- log(logit.nest(exp(fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n]), 0.8, 1000,4)$x)
summary(exp(initial.linpoint))
initial.linpoint <- log(logit.nest(exp(fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n]), 0.8, 500,4)$x)
summary(exp(initial.linpoint))
out.lgcp$animal_obs <- mutate(out.lgcp$animal_obs, y = obs)
iterated.fit.lgcp <- iterate.cgeneric.fit.gaussian(data = out.lgcp$animal_obs, smesh = mesh_obs, tmesh = mesh_time,
samplers = bnd,prior.mean = fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n],
prior.precision = initial.precision, priors = priors,
max.iter = 100,gamma = 0.5,
stop.crit = 0.005,
initial.linpoint = initial.linpoint, initial.growth = log(0.8),
initial.log.sigma = log(0.1),
initial.move.const = 0.25,
initial.carry.cap = log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,])),
saveall = F, options = list(verbose = T))
roxygen2::roxygenise()
setwd("~/GitHub/INLAlogrowth-package")
roxygen2::roxygenise()
#' @param stop.crit stopping criteria for linearisation point update rule. Stop updating if mean(abs(new_linearisation_point-old_linearisation_point))<=stop.crit
#' @param priors named list of prior parameters, named \code{cc} (carrying capacity), \code{growth}, \code{move}, \code{sigma}.
#' Each is a two element vector containing the mean and variance for parameter.
#' @param initial.linpoint Optional. Starting guess for the linearisation point. If NULL, will be estimated within function
#' @param initial.growth,initial.carry.cap,initial.move.const,initial.log.sigma Starting values for the growth,
#' \emph{log} carrying capacity, movement constant and \emph{log} standard deviation
#' @param verbose logical supplied to INLA
#' @returns list containing final model fit, number of iterations \code{n}, matrix of all past linearisation points and list of all past model fits.
#'@import inlabru
#'@export
iterate.cgeneric.fit.gaussian <- function(data, smesh, tmesh, samplers,prior.mean,
prior.precision, max.iter = 100,gamma = 0.75,stop.crit = 0.05,
priors = NULL,initial.linpoint = NULL, initial.growth=1,
initial.carry.cap=0.05, initial.move.const = 1, initial.log.sigma = log(1.5),
options = list(verbose = F,
control.inla = list(control.vb=list(emergency=30),int.strategy = 'eb')),
saveall = T){
#browser()
step.size = (tmesh$interval[2]-tmesh$interval[1])/(tmesh$n-1) #calculate step size. -1 in denom due to fence post problem
if(is.null(initial.linpoint)){
initial.linpoint <- log(logit.nest(exp(prior.mean), exp(initial.growth), exp(initial.carry.cap), tmesh$n)$x)
}
if(!is.matrix(initial.linpoint)) initial.linpoint <- as.matrix(initial.linpoint, ncol = 1)
fit.list <- list()
#Set up initial model
log_growth_model <- define.cgeneric.loggrow.model(linpoint = initial.linpoint,
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma, debug = debug)
fit <- bru(y ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n)-1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "gaussian", options = options)
if(saveall){
fit.list[[1]]<-fit
}else{
fit.list <- fit
}
print("First fitting finished")
n.nodes <- fit$misc$configs$nconfig
nodes <- data.frame(log.prob=rep(NA,n.nodes))
#mat_list <- list()
mean_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- c(fit$misc$configs$config[[i]]$log.posterior)
#mat_list[[i]] <- fit$misc$configs$config[[i]]$Q[1:(smesh$n*tmesh$n), 1:(smesh$n*tmesh$n)]
mean_list[[i]] <- fit$misc$configs$config[[i]]$improved.mean[1:(smesh$n*tmesh$n)]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
#Old rule- in theory faster but gives some extreme changes
#P <- Reduce("+", Map(function(m, w) m * w, mat_list, nodes$weight.prob))
#weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
#b <- Reduce("+", Map(function(m,w) m%*%w, mat_list,weighted.means))
#new.linpoint <- (1-gamma)*initial.linpoint +gamma*solve(P,b)
#New update rule
weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
new.mean <- Reduce("+", weighted.means)
#print(new.mean)
new.linpoint <- (1-gamma)*initial.linpoint +gamma*new.mean
#plot(new.linpoint)
lp.mat <- cbind(initial.linpoint,new.linpoint)
n <- 2
#print(fit$summary.hyperpar$mean)
#Iterate the updates
while(n < max.iter & mean(abs(lp.mat[,n]-lp.mat[,n-1]))>stop.crit){
log_growth_model <- define.cgeneric.loggrow.model(linpoint = as.vector(new.linpoint),
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma,
#initial.growth = fit$summary.hyperpar$mean[1],
#initial.carry.cap = fit$summary.hyperpar$mean[2],
#initial.move.const = fit$summary.hyperpar$mean[3],
#initial.log.sigma = fit$summary.hyperpar$mean[4],
debug = debug)
#initial.growth = initial.growth,
#initial.carry.cap = initial.carry.cap,
#initial.move.const = initial.move.const,
#initial.log.sigma = initial.log.sigma)
print("Defined new model")
fit <- bru(y ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n)-1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "gaussian", options = options)
print(paste("Fitted new model", n))
n.nodes <- fit$misc$configs$nconfig
if(!is.numeric(n.nodes)){
print("Failed to fit, trying again")
fit <- bru(y ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n)-1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "gaussian", options = options)
if(!is.numeric(fit$misc$configs$nconfig)){
print("Failed again, returning model output")
return(list(new.linpoint = new.linpoint,fit = fit, past.linpoints = lp.mat, fit.list = fit.list))
}
n.nodes <- fit$misc$configs$nconfig
}
if(saveall){
fit.list[[n]]<-fit
}else{
fit.list <- fit
}
nodes <- data.frame(log.prob=rep(NA,n.nodes))
#mat_list <- list()
mean_list <- list()
for(i in 1:n.nodes){
nodes[i,]<- c(fit$misc$configs$config[[i]]$log.posterior)
#mat_list[[i]] <- fit$misc$configs$config[[i]]$Q[1:(smesh$n*tmesh$n),1:(smesh$n*tmesh$n)]
mean_list[[i]] <- fit$misc$configs$config[[i]]$improved.mean[1:(smesh$n*tmesh$n)]
}
nodes <- dplyr::mutate(nodes, weight = exp(log.prob)) %>%
dplyr::mutate(weight.prob = weight/sum(weight))
#Old rule- in theory faster but gives some extreme changes
#P <- Reduce("+", Map(function(m, w) m * w, mat_list, nodes$weight.prob))
#weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
#b <- Reduce("+", Map(function(m,w) m%*%w, mat_list,weighted.means))
#new.linpoint <- (1-gamma)*initial.linpoint +gamma*solve(P,b)
#New update rule
weighted.means <- Map(function(v,p) v*p, mean_list, nodes$weight.prob)
new.mean <- Reduce("+", weighted.means)
new.linpoint <- (1-gamma)*lp.mat[,n] +gamma*new.mean
#plot(new.linpoint, main = paste("Linearisation point", n))
lp.mat <- cbind(lp.mat,new.linpoint)
print("Updated linpoint")
n <- n+1
}
log_growth_model <- define.cgeneric.loggrow.model(linpoint = as.vector(new.linpoint),
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean,
prior.precision = prior.precision, priors = priors,
initial.growth = initial.growth,
initial.carry.cap = initial.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma,
#initial.growth = fit$summary.hyperpar$mean[1],
#initial.carry.cap = fit$summary.hyperpar$mean[2],
#initial.move.const = fit$summary.hyperpar$mean[3],
#initial.log.sigma = fit$summary.hyperpar$mean[4],
debug = debug)
#initial.growth = initial.growth,
#initial.carry.cap = initial.carry.cap,
#initial.move.const = initial.move.const,
#initial.log.sigma = initial.log.sigma)
print("Defined final model")
final.fit <- bru(y ~ loggrow(list(space = geometry, time = time),
model = log_growth_model,
n = smesh$n*tmesh$n)-1,
data = data, domain = list(geometry = smesh,time = tmesh),
samplers = samplers,
family = "gaussian", options = options)
return(list(fit = final.fit, n = n, linpoints = lp.mat, fit.list = fit.list))
}
iterated.fit.lgcp <- iterate.cgeneric.fit.gaussian(data = out.lgcp$animal_obs, smesh = mesh_obs, tmesh = mesh_time,
samplers = bnd,prior.mean = fit0$summary.fixed$mean +fit0$summary.fitted.values$mean[index-1 +1:mesh_obs$n],
prior.precision = initial.precision, priors = priors,
max.iter = 100,gamma = 0.5,
stop.crit = 0.005,
initial.linpoint = initial.linpoint, initial.growth = log(0.8),
initial.log.sigma = log(0.1),
initial.move.const = 0.25,
initial.carry.cap = log(nrow(out.lgcp$animal_obs[out.lgcp$animal_obs$time == 4,])),
saveall = F, options = list(verbose = T))
