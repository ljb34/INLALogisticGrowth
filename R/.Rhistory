return(the_model)
}
#'@name bru_get_mapper.log_growth_model
#' @title Mapper function for internal use
#' @export
bru_get_mapper.log_growth_model <- function(model, ...) {
stopifnot(requireNamespace("inlabru"))
inlabru::bru_mapper_multi(list(
space = inlabru::bru_mapper(model[["smesh"]]),
time = inlabru::bru_mapper(model[["tmesh"]], indexed = TRUE)
))
}
library(INLA)
library(INLAspacetime)
library(inlabru)
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.wrapper("Q", logit_model, theta = theta)
return(precision)
}
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.05)
mesh_time <- fm_mesh_1d(loc = 1:4)
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.wrapper(cmd = "Q", logit_model, theta = theta)
return(precision)
}
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.1)
mesh_time <- fm_mesh_1d(loc = 1:4)
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
#'@name define.loggrow.model
#'@title Define logistic growth model
#'@description
#'Defines latent model and mapper for log.growth.regeneric
#'@param linpoint Linearisation point
#'@param smesh spatial mesh created with fm_mesh_2d_inla
#' @param tmesh mesh over equally spaced time pointes created with fm_mesh_1d
#'@param step.size difference between each of the time points
#'@param prior.mean estimated mean for first year of data. Helper function for calculating coming soon
#'@param prior.variance uncertainty for estimated mean of first year of data. Helper function for calculating coming soon
#'@param priors named list of prior parameters, named \code{cc} (carrying capacity), \code{growth}, \code{move}, \code{sigma}.
#' cc is a two element vector containing the shape and rate parameter for gamma prior of the inverse carrying capacity.
#' The others are two element vectors containing the mean and variance for the other parameters.
#' @param initial.growth,initial.inv.carry.cap,initial.move.const,initial.log.sigma Starting values for the growth,
#' inverse carrying capacity, movement constant and \emph{log} standard deviation
#'@returns INLA rgeneric model
#'@export
define.loggrow.model <- function(linpoint, smesh, tmesh, step.size,
prior.mean, prior.variance, priors = NULL,
initial.growth = NULL, initial.inv.carry.cap = NULL,
initial.move.const = NULL, initial.log.sigma = NULL){
the_model <- inla.rgeneric.define(log.growth.rgeneric,
linpoint = linpoint,
smesh = smesh,tmesh = tmesh, step.size = step.size,
prior.mean = prior.mean, priors = priors,
prior.variance = prior.variance,
initial.growth = initial.growth,
initial.inv.carry.cap = initial.inv.carry.cap,
initial.move.const = initial.move.const,
initial.log.sigma = initial.log.sigma)
class(the_model) <- c("log_growth_model", class(the_model))
the_model[["smesh"]] <- smesh
the_model[["tmesh"]] <- tmesh
return(the_model)
}
#'@name bru_get_mapper.log_growth_model
#' @title Mapper function for internal use
#' @export
bru_get_mapper.log_growth_model <- function(model, ...) {
stopifnot(requireNamespace("inlabru"))
inlabru::bru_mapper_multi(list(
space = inlabru::bru_mapper(model[["smesh"]]),
time = inlabru::bru_mapper(model[["tmesh"]], indexed = TRUE)
))
}
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.wrapper(cmd = Q(), logit_model, theta = theta)
return(precision)
}
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.1)
mesh_time <- fm_mesh_1d(loc = 1:4)
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.25)
mesh_time <- fm_mesh_1d(loc = 1:4)
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.wrapper(cmd = Q, logit_model, theta = theta)
return(precision)
}
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
?match.arg
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.wrapper("Q", logit_model, theta = theta)
return(precision)
}
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.25)
mesh_time <- fm_mesh_1d(loc = 1:4)
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.wrapper(cmd = "Q", logit_model, theta = theta)
return(precision)
}
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.25)
mesh_time <- fm_mesh_1d(loc = 1:4)
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.wrapper(cmd = "Q", model = logit_model, theta = theta)
return(precision)
}
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.25)
mesh_time <- fm_mesh_1d(loc = 1:4)
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
inla.logrowth.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = rep(1, smesh$n), smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
return(precision)
}
bnd_extended <- spoly(data.frame(easting = c(0,2,2,0),
northing = c(0,0,2,2)))
mesh_extended <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.25)
mesh_time <- fm_mesh_1d(loc = 1:4)
test.p<- inla.logrowth.precision(mesh_extended, mesh_time, c(1,log(1/20),1,1), 10)
test.p
setwd("~/GitHub/INLAlogrowth-package/R")
logit.growth <- function(x,r,k){
x[x<0]<-0
xnew <- x*exp(r*(1-(x/k)))
return(xnew)
}
#'Nested logistic growth
#'Deterministic function for calculating population size over multiple time steps of growth
#'  @param x0 numeric or vector starting population
#'  @param r numeric or vector growth rate
#'  @param k numeric or vector carrying capacity
#'  @param n number of time steps to compute
#'  @returns dataframe of population size and time
#'  @export
logit.nest <- function(x0,r,k,n){
df <- data.frame(x = x0, time = rep(1, length(x0)))
for(i in 2:n){
df <- rbind(df,
data.frame(x = logit.growth(df$x[df$time == i-1], r,k),
time = rep(i, length(x0))))
}
return(df)
}
#'Functions for simulating growth
simulate.loggrowth2<- function(growth, k, movement, sigma,
initial, timesteps, npoints = NULL, obs.sd=NULL,
sample.type = "LGCP", ncores = 1,
boundaries = c(0,1)){
corners <- c(boundaries[1] - movement, boundaries[2]+movement)
bnd_extended <- spoly(data.frame(easting = c(corners[1], corners[2],corners[2],corners[1]),
northing = c(corners[1], corners[1],corners[2],corners[2])))
mesh_space <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.05)
mesh_time <- fm_mesh_1d(loc = 1:timesteps)
matrices <- inla.logrowth.mean.precision(mesh_space, mesh_time, c(growth, log(k), movement, log(sigma)),
initial)
field <- inla.qsample(1, matrices$Q, mu = matrices$mean)[, 1]
field$time <- rep(1:timesteps, each = mesh_space$time)
expand_for_plot <- function(i){
animal_tempsf <- expand.grid(
easting = seq(corners[1],corners[2], by = 0.01),
northing = seq(corners[1],corners[2], by = 0.01))
animal_tempsf <- mutate(sf::st_as_sf(animal_tempsf, coords = c("easting", "northing")),
time = i)
animal_tempsf$field <- fm_evaluate(
mesh_extended,
loc = animal_tempsf,
field = field$field[field$time == i])
return(animal_tempsf)
}
expanded <- parallel::mclapply(1:timesteps, expand_for_plot,  mc.cores = ncores)
animal <- do.call(rbind, expanded)
return(list(field = field, animal = animal))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200)
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
inla.logrowth.mean.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
linpoint <- logit.nest(rep(initial,smesh$n), theta[1], exp(theta[2]), tmesh$n)$x
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = linpoint, smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
mu <- inla.rgeneric.q(cmd = "mu", rmodel = logit_model, theta = theta)
return(list(Q = precision, mean = mu))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
#'Functions for simulating growth
simulate.loggrowth2<- function(growth, k, movement, sigma,
initial, timesteps, npoints = NULL, obs.sd=NULL,
sample.type = "LGCP", ncores = 1,
boundaries = c(0,1)){
corners <- c(boundaries[1] - movement, boundaries[2]+movement)
bnd_extended <- spoly(data.frame(easting = c(corners[1], corners[2],corners[2],corners[1]),
northing = c(corners[1], corners[1],corners[2],corners[2])))
mesh_space <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.25)
mesh_time <- fm_mesh_1d(loc = 1:timesteps)
matrices <- inla.logrowth.mean.precision(mesh_space, mesh_time, c(growth, log(k), movement, log(sigma)),
initial)
field <- inla.qsample(1, matrices$Q, mu = matrices$mean)[, 1]
field$time <- rep(1:timesteps, each = mesh_space$time)
expand_for_plot <- function(i){
animal_tempsf <- expand.grid(
easting = seq(corners[1],corners[2], by = 0.01),
northing = seq(corners[1],corners[2], by = 0.01))
animal_tempsf <- mutate(sf::st_as_sf(animal_tempsf, coords = c("easting", "northing")),
time = i)
animal_tempsf$field <- fm_evaluate(
mesh_extended,
loc = animal_tempsf,
field = field$field[field$time == i])
return(animal_tempsf)
}
expanded <- parallel::mclapply(1:timesteps, expand_for_plot,  mc.cores = ncores)
animal <- do.call(rbind, expanded)
return(list(field = field, animal = animal))
}
inla.logrowth.mean.precision <- function(smesh, tmesh, theta, initial){
#browser()
movement <- theta[3]
sigma <- exp(theta[4])
linpoint <- logit.nest(rep(initial,smesh$n), theta[1], exp(theta[2]), tmesh$n)$x
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = linpoint, smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
mu <- inla.rgeneric.q(cmd = "mu", rmodel = logit_model, theta = theta)
return(list(Q = precision, mean = mu))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
#'Functions for simulating growth
simulate.loggrowth2<- function(growth, k, movement, sigma,
initial, timesteps, npoints = NULL, obs.sd=NULL,
sample.type = "LGCP", ncores = 1,
boundaries = c(0,1)){
browser()
corners <- c(boundaries[1] - movement, boundaries[2]+movement)
bnd_extended <- spoly(data.frame(easting = c(corners[1], corners[2],corners[2],corners[1]),
northing = c(corners[1], corners[1],corners[2],corners[2])))
mesh_space <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.25)
mesh_time <- fm_mesh_1d(loc = 1:timesteps)
matrices <- inla.logrowth.mean.precision(mesh_space, mesh_time, c(growth, log(k), movement, log(sigma)),
initial)
field <- inla.qsample(1, matrices$Q, mu = matrices$mean)[, 1]
field$time <- rep(1:timesteps, each = mesh_space$time)
expand_for_plot <- function(i){
animal_tempsf <- expand.grid(
easting = seq(corners[1],corners[2], by = 0.01),
northing = seq(corners[1],corners[2], by = 0.01))
animal_tempsf <- mutate(sf::st_as_sf(animal_tempsf, coords = c("easting", "northing")),
time = i)
animal_tempsf$field <- fm_evaluate(
mesh_extended,
loc = animal_tempsf,
field = field$field[field$time == i])
return(animal_tempsf)
}
expanded <- parallel::mclapply(1:timesteps, expand_for_plot,  mc.cores = ncores)
animal <- do.call(rbind, expanded)
return(list(field = field, animal = animal))
}
inla.logrowth.mean.precision <- function(smesh, tmesh, theta, initial){
#browser()
movement <- theta[3]
sigma <- exp(theta[4])
linpoint <- logit.nest(rep(initial,smesh$n), theta[1], exp(theta[2]), tmesh$n)$x
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = linpoint, smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
mu <- inla.rgeneric.q(cmd = "mu", rmodel = logit_model, theta = theta)
return(list(Q = precision, mean = mu))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
mesh_space$n
inla.logrowth.mean.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
linpoint <- logit.nest(rep(initial,smesh$n), theta[1], exp(theta[2]), tmesh$n)$x
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = linpoint, smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
mu <- inla.rgeneric.q(cmd = "mu", rmodel = logit_model, theta = theta)
return(list(Q = precision, mean = mu))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
dim(initial_Q)
inla.logrowth.mean.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
linpoint <- logit.nest(rep(initial,smesh$n), theta[1], exp(theta[2]), tmesh$n)$x
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = linpoint, smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
mu <- inla.rgeneric.wrapper(cmd = "mu", model = logit_model, theta = theta)
return(list(Q = precision, mean = mu))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
inla.logrowth.mean.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
linpoint <- logit.nest(rep(initial,smesh$n), theta[1], exp(theta[2]), tmesh$n)$x
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = linpoint, smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
mu <- inla.rgeneric.q(cmd = "mu", model = logit_model, theta = theta)
return(list(Q = precision, mean = mu))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
#'Functions for simulating growth
simulate.loggrowth2<- function(growth, k, movement, sigma,
initial, timesteps, npoints = NULL, obs.sd=NULL,
sample.type = "LGCP", ncores = 1,
boundaries = c(0,1)){
browser()
corners <- c(boundaries[1] - movement, boundaries[2]+movement)
bnd_extended <- spoly(data.frame(easting = c(corners[1], corners[2],corners[2],corners[1]),
northing = c(corners[1], corners[1],corners[2],corners[2])))
mesh_space <- fm_mesh_2d_inla(boundary = bnd_extended, max.edge = 0.3)
mesh_time <- fm_mesh_1d(loc = 1:timesteps)
matrices <- inla.logrowth.mean.precision(mesh_space, mesh_time, c(growth, log(k), movement, log(sigma)),
initial)
field <- inla.qsample(1, matrices$Q, mu = matrices$mean)[, 1]
field$time <- rep(1:timesteps, each = mesh_space$time)
expand_for_plot <- function(i){
animal_tempsf <- expand.grid(
easting = seq(corners[1],corners[2], by = 0.01),
northing = seq(corners[1],corners[2], by = 0.01))
animal_tempsf <- mutate(sf::st_as_sf(animal_tempsf, coords = c("easting", "northing")),
time = i)
animal_tempsf$field <- fm_evaluate(
mesh_extended,
loc = animal_tempsf,
field = field$field[field$time == i])
return(animal_tempsf)
}
expanded <- parallel::mclapply(1:timesteps, expand_for_plot,  mc.cores = ncores)
animal <- do.call(rbind, expanded)
return(list(field = field, animal = animal))
}
inla.logrowth.mean.precision <- function(smesh, tmesh, theta, initial){
browser()
movement <- theta[3]
sigma <- exp(theta[4])
linpoint <- logit.nest(rep(initial,smesh$n), theta[1], exp(theta[2]), tmesh$n)$x
matern <-
inla.spde2.pcmatern(smesh,
prior.sigma = c(0.1, 0.1),
prior.range = c(0.1, 0.1))
initial_Q <- inla.spde.precision(matern,
theta = log(c(movement, sigma)))
logit_model <- define.loggrow.model(linpoint = linpoint, smesh = smesh, tmesh = tmesh,
step.size = 1, prior.mean = rep(initial, smesh$n),
prior.variance = solve(initial_Q))
precision <- inla.rgeneric.q(cmd = "Q", rmodel = logit_model, theta = theta)
mu <- inla.rgeneric.q(cmd = "mu", rmodel = logit_model, theta = theta)
return(list(Q = precision, mean = mu))
}
test.out <- simulate.loggrowth2(0.75,500,1,1,200,4)
